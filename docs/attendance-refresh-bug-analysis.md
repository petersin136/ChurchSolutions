# 출석부 새로고침 시 결석으로 바뀌는 버그 — 원인 분석

## 현상
- 출석 체크에서 출석 선택 후 저장 → 저장 성공
- 새로고침 3~4번 반복하면 저장했던 출석이 다시 **결석**으로 표시됨

---

## 데이터 흐름 요약

1. **로드**: `loadAttendance(selectedDate, selectedServiceType)` → Supabase `attendance` 테이블 조회 → `setStatusMap(newMap)` 한 번만 호출
2. **표시**: `statusMap[memberId] ?? "결석"` → 한 곳에서만 읽음
3. **저장**: `statusMap` 기준으로 `UI_TO_DB_STATUS` 변환 후 upsert

즉, **화면에 보이는 값은 전부 `statusMap` 하나**에만 의존한다.  
그래서 “랜덤하게 바뀐다”면, **어떤 시점에 `statusMap`이 빈 객체 `{}`로 설정되거나, 로드 결과가 빈 배열로 들어오는 경우**라고 보는 것이 맞다.

---

## 가능 원인 (우선순위)

### 1. **날짜 초기값이 UTC 기준이라, 로컬 날짜와 어긋남 (가능성 높음)**

```ts
// AttendanceCheck.tsx 52–53행
const today = useMemo(() => new Date().toISOString().slice(0, 10), []);
const [selectedDate, setSelectedDate] = useState(today);
```

- `toISOString()`은 **UTC** 기준이다.
- 예: 한국 2026-02-19 02:00 (KST) → UTC 2026-02-18 17:00 → `today` = **"2026-02-18"**
- 사용자가 **로컬 기준 19일**에 출석 저장하면 DB에는 `date = 2026-02-19`로 들어감.
- 새로고침 후에는 `selectedDate`가 다시 `today` = "2026-02-18"로 초기화됨.
- 이 상태로 `loadAttendance("2026-02-18", ...)` 호출 → 19일 데이터는 조회되지 않음 → `newMap = {}` → 전원 결석으로 보임.

**언제 “가끔”만 나올 수 있나**  
- 자정 전후, 또는 UTC 자정 전후에 테스트하면 “같은 날”로 보이다가 새로고침 후 UTC 날짜가 바뀌면서 전날/다음날로 쿼리될 수 있음.
- 또는 새로고침 타이밍에 따라 `today`가 하루 차이로 바뀌면, 3~4번 중 몇 번은 맞다가 몇 번은 결석으로 보일 수 있음.

**확인 방법**
- 브라우저 콘솔에서 매 로드 시:
  - `[출석 로드]` 로그의 `date`, `count`, `statusMap` 확인.
- 수동으로:
  - 날짜 입력을 **저장한 날짜와 동일한 값**으로 맞춘 뒤 새로고침 → 그때는 출석이 유지되는지 확인.

---

### 2. **Supabase 조회가 가끔 빈 배열을 반환 (네트워크/RLS/캐시)**

- 로드는 `loadAttendance` 한 번의 `select` 결과만 사용한다.
- 그 결과가 **가끔** 빈 배열이면 → `newMap = {}` → `setStatusMap({})` → 전원 결석.

가능한 이유:
- **RLS**: `auth.uid()`가 아직 없거나, 세션 복원 전에 요청이 나가면 RLS로 행이 걸러질 수 있음.
- **네트워크**: 타임아웃/실패 시 현재 코드는 `setStatusMap({})` 호출 (에러 분기).
- **캐시**: 브라우저/프록시가 이전의 빈 응답을 캐시해 줄 수 있음 (드묾).

**확인 방법**
- 콘솔에서:
  - `[출석 로드]` 의 `count`, `statusMap`이 새로고침할 때마다 0/빈 객체로 나오는지.
  - `[출석 로드 실패]` 로 에러가 찍히는지.
- Supabase 대시보드 → Table Editor에서 해당 `date` / `service_type` 행이 실제로 있는지, 새로고침 후에도 동일한지 확인.

---

### 3. **React StrictMode 등으로 effect가 두 번 돌 때, “나중에 끝난 요청”이 빈 결과인 경우**

- `loadingRef`로 동시에 두 번 들어가는 것은 막았지만,  
  **첫 요청은 스킵되고, 두 번째 요청만 나가고, 그 두 번째 요청이 빈 결과를 주면** 결석으로 보일 수 있음.
- 또는 **먼저 끝난 요청이 유효한 데이터를 넣었는데, 그 다음에 끝난 요청이 빈 결과로 `setStatusMap({})`를 호출**하면 덮어써서 결석으로 보일 수 있음.  
  (현재는 `requestId`로 “마지막 요청만” 반영하므로, “마지막 요청이 빈 결과”인 경우에 해당.)

**확인 방법**
- 콘솔 `[loadAttendance 호출]` / `[loadAttendance 호출] 스킵(이미 로딩 중)` 로, 호출 횟수와 스킵 여부 확인.
- “스킵”이 찍힌 뒤에도 한 번은 요청이 나가고, 그때의 `count`가 0이면 위와 같은 상황일 수 있음.

---

### 4. **예배(service_type) 불일치**

- `selectedServiceType` 초기값: `useState(serviceTypes[0]?.name || "주일1부예배")`.
- 저장은 사용자가 선택한 예배로 했는데, **새로고침 후** `serviceTypes`가 비어 있거나 순서가 바뀌어 `serviceTypes[0]?.name`이 달라지면, 다른 예배로 조회하게 됨 → 해당 예배에 행이 없으면 빈 결과 → 결석.

**확인 방법**
- `[출석 로드]` 로그에서 `serviceType` 값이 저장 시 사용한 예배와 동일한지 확인.
- PastoralPage에서 `serviceTypes`가 어디서 오는지(초기값/API) 확인 후, 첫 렌더와 이후 렌더에서 `serviceTypes[0]?.name`이 바뀌지 않는지 확인.

---

### 5. **컴포넌트가 새로 마운트되면서 상태 초기화**

- `activeSub === "attendance"` / `attendanceSubTab === "check"` 일 때만 `<AttendanceCheck />`가 마운트됨.
- 상위에서 **키 변경**이나 **조건 변경**으로 이 컴포넌트가 자주 unmount/remount 되면, 매번 `statusMap = {}`로 시작한 뒤 `loadAttendance` 결과만으로 채워짐.
- 그런데 **그 로드가 빈 결과**면 (위 1, 2, 4번 이유로) 결석으로 보임.

즉, “3~4번 새로고침”이 꼭 3~4번의 **전체 페이지 리로드**가 아니라,  
탭 전환/라우트 등으로 인한 **3~4번의 마운트**일 수도 있음.

---

## 정리: 우선 확인할 것

1. **날짜**
   - 로드 시 `[출석 로드]` 의 `date`가 **실제로 저장한 날짜(로컬 기준)**와 같은지.
   - `today` 초기값을 로컬 날짜로 바꿔보면 현상이 사라지는지 (수정은 나중에).

2. **조회 결과**
   - 새로고침할 때마다 `count`가 0이 되는 시점이 있는지, 그때 `date`/`serviceType`이 무엇인지.

3. **에러**
   - `[출석 로드 실패]` 가 새로고침 중에 찍히는지.

4. **DB**
   - Supabase에서 해당 `date` / `service_type` / `member_id` 로 행이 확실히 남아 있는지.

이 네 가지를 먼저 확인한 뒤,  
- 날짜가 어긋나면 → 초기값을 로컬 날짜로 통일하거나, 선택한 날짜를 localStorage 등에 유지하는 방향으로 수정하고,  
- 조회가 가끔 빈 결과면 → RLS/네트워크/재시도 로직을 보는 식으로 **원인별로 한 가지씩** 수정하는 것이 좋다.

**이 문서는 원인 분석만 담았으며, 코드 변경은 포함하지 않았습니다.**
